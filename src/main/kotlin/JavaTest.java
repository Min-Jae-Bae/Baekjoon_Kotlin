

public class JavaTest {

}

class StaticSample {

    /*NonStatic
     * 객체 생성될 때 마다  NonStatic 멤버 생성
     * 클래스 이름으로 접근 불가능
     * Static 멤버들 모두 사용 가능*/
    int n;  //필드

    void g() {/*...*/} //메소드

    /*Static
     * 클래스당 하나만 생성 , 즉 객체들끼리 공유
     * 클래스 이름, 객체 멤버로 접근 가능
     * 전역 변수, 전역 함수, 공유 멤버 만들 때 활용
     * Static 메소드는 오직 Static 멤버만 접근 가능
     * this 키워드 사용 불가*/
    static int m;

    static void f() {/*...*/}
}


final class FinalClass {

    /*final
     *final 클래스, final 메소드는 더 이상 상속, 오버라이딩 불가능
     *final 상수 필드는 선언 시 초기 값 지정 및 변경 불가능*/

}

/*클래스의 상속 (extends) -> 중복된 멤버를 제거하고 클래스를 간결하게 만듬
 *
 * 상속 특징 -> 다중 상속 X, 모든 클래스 Objeect 클래스 상속받음
 *
 * 슈퍼 클래스 객체와 서브 클래스의 객체는 별개이다
 * 서브 클래스 객체는 슈퍼 클래스 멤버 포함
 *
 * default 클래스 -> 다른 패키지의 클래스, 서브 클래스 접근 X
 * protected 클래스 -> 다른 패키지의 클래스 접근 X 서브 클래스 O
 *
 * 서브 클래스 객체 생성시:
 * 슈퍼/서브 클래스 생성자 모두 실행 (단 슈퍼 클래스의 생성자가 먼저 실행)
 * 순서: 서브 클래스 생성자 호출 -> 슈퍼 클래스 생성자 호출 -> 슈퍼 클래스 생성자 실행 -> 서브 클래스 생성자 실행
 *
 * 기본 생성자 자동 선택: public B() {...} -> public A() {...}
 * 기본 생성자 자동 선택(불가능) A 생성자는 기본 생성자가 아님: public B() {...} -> public A(int x) {...}
 *
 * 생성자 선택 호출: super() - 반드시 생성자 코드 제일 첫 라인에 존재
 *
 *
 * 업캐스팅:
 * class Person {...}
 * class Student extends Person {...}
 * Person p; // 슈퍼 클래스 레퍼런스
 * Students s = new Student();
 * p = s; // 업 캐스팅. 서브 클래스의 레퍼런스를 슈퍼 클래스 레퍼런스에 대입
 * p.grade는 Person 멤버가 아니므로 오류
 *
 * 다운캐스팅: 슈퍼 클래스 래퍼런스 -> 서브 클래스 레퍼런스에 대입
 * class Person {...}
 * class Student extends Person {...}
 * Person p = new Stduent("xxx"); // 업캐스팅
 * Stduent s = (Student)p; // 다운캐스팅. 업캐스팅된 것을 다시 원래대로 복구
 * p.grade는 오류 없음
 *
 * instanceof 연산자: 레퍼런스가 가리키는 객체 타입 식별, 연산 결과는 true/false
 * 객체 레퍼런스 instanceof 클래스타입
 * (3 instanceof int)는 오류: 객체 레퍼런스만 사용
 *
 * */





/* 메소드 오버라이딩: 서브 클래스에서 슈퍼 클래스의 메소드 중복 작성
 실행 조건: 슈퍼 클래스 메소드 동일하게 작성*/
class A {
    void f() {/*"Hello*/} //존재감 상실
}

class B extends A {
    @Override
    void f() {/*Hi*/}  //오버라이딩 및 다형성(하나의 이름에 다른 구현) 실현
}

/*오버로딩
* 같은 클래스 및 상속 관계 동일 이름 메소드 중복 작성
* 메소드 중복 선언하여 편리성 향상
* 메소드 이름 동일, 메소드 인자 갯수, 타입 달라야 함
* 정적 바인딩(중복된 메소드 중 호출되는 메소드 결정) - super()로 메소드 호출, ex) super.draw(); -> 슈퍼 클래스 draw() 생성자
* */

/*오버라이딩
* 슈퍼 클래스에 있는 메소드와 동일한 이름의 메소드 재작성
* 슈퍼 클래스 메소드 무시, 서브 클래스에 새로운 기능 메소드 재정의
* 메소드 이름, 인자 갯수, 타입 동일해야 함
* 동적 바인딩(실행 시간에 오버라이딩된 메소드 찾아 호출) - 슈퍼 클래스 draw() -> 서브 클래스 draw() 생성자*/

/*추상 메소드(abstract): 틀만 선언, 인스턴스 생성 불가
* 추상 클래스는 반드시 추상 메소드를 가짐.
* 추상 클래스를 상속 받으면 서브 클래스도 abstract 선언*/

